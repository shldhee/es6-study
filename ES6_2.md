# ES6_2

## 디스트럭처링
```js
let one, two;
[one, two] = [1, 2];

console.log(one, two); // 1, 2
```
오른쪽의 배열을 엘리먼트로 분할하고 엘리먼트 값을 왼쪽 변수에 할당


### Array 분할 할당
```js
let one, two, three, four, five;
const values = [1, 2, 3];

[one, two, three] = values;
console.log("A:", one, two, three); // 1 2 3

[one, two] = values;
console.log("B:", one, two); // 1 2

[one, two, three, four] = values;
console.log("C:", one, two, three, four); // 1 2 3 undefined

[one, two, [three, four]] = [1, 2, [73, 74]];
console.log("D:", one, two, three ,four); // 1 2 73 74
```

***왼쪽과 오른쪽읠 배열 차원이 같지 않으면 에러가 발생합니다.***

### Object 분할 할당
```js
// 변수 선언과 할당을 한 번에 하기
let {one, two} = {one: 1, nine: 9};
console.log(one, two); // 1 undefined
// 오른쪽 오브젝트의 nine이 왼쪽 오브젝트에 없다.

let three, four;
({three, four} = { three: 3, four: 4 });
console.log(three, four); // 3 4

let five, six;
({one: five, two: six} = {one: 10, two: 20});
console.log(five, six); // 10 20
/*
    왼쪽, 오른쪽 오브젝트에 one 존재 one은 변수가 아닌 프로퍼티 키
    프로퍼티 키 값이 같은 five 변수에 10, six 변수에 20 할당
*/


let {nine, plus: {ten}} = {nine: 9, plus: {ten: 10}};
console.log(nine, ten); // 9 10
```
***오른쪽의 Object 오브젝트를 프로퍼티 단위로 분할하고 프로퍼티 키와 이름이 같은 왼쪽 변수에 값을 할당합니다.***

### 파라미터 분할 할당
```js
function total({one, plus: {two, five}}) {
    console.log(one + two + five);
};
total({one:1 , plus: {two: 2, five: 5}}); //8

/*
    호출하는 함수의 파라미터를 Object 오브젝트 형태로 작성
    호출받는 함수의 파라미터를 Object 오브젝트의 분할 할당 형태로 작성
*/
```

## 오퍼레이션

### 프로퍼티 이름 조합
#### 문자열 조합
```js
let item = {
    ["one"+"two"]: 12 // === onetwo: 12
}
console.log(item.onetwo);
//오브젝트 프로퍼티 이름을 문자열, 변수 조합으로 사용이 가능하다.
```

#### 변수 값과 문자열 조합
```js
let item = "tennis";
let sports = {
    [item]: 1, // ["tennis"]
    [item + "Game"]: "윔블던", //["tennisGame"]
    [item + "Method"](){ //["tennisMethod"]
        return this[item];
    }
};

console.log(sports.tennis); //1
console.log(sports.tennisGame); // 윔블던
console.log(sports.tennisMethod()); // 1
```
[items]과 같이 대괄호 []안에 변수 이름을 작성하면 변수 값을 프로퍼티 키로 사용합니다.

#### 디스트럭처링과 프로퍼티 이름 조합
```js
let one = "sports";
let {[one]: value} = {sports : "농구"}; //[one] = ["sports"] -> {sports: value}
console.log(value);
```
`{sports : "농구"}` 디스트럭처링으로 오브젝트 분할 할당
sports가 왼쪽 `[one] = sports` 키 값이랑 일치한다

### Default Value
```js
let [one, two, five = 5] = [1, 2];
console.log(five); // 5

[one, two, five = 5] = [1, 2, 77];
console.log(five); // 77

let {six, seven = 7} = {six: 6};
console.log(six, seven); //6 7

//디폴트 값(default value)은 let 변수를 선언하면서 값이 설정되지 않았을 때 할당될 값을 작성해 두는 형태
```

#### 디폴트 값 적용 순서
```js
let [one, two = one + 1, five = two + 3] = [1];
console.log(one, two, five);

//디폴트 값 적용 순서 = 왼쪽에서 오른쪽으로
```
[1]이 one에 할당

### Default 파라미터
```js
let plus = (one, two = 2) => one + two; // 호출하는 함수에서 파라미터 값을 넘겨주지 않거나 undefined를 넘겨주면 디폴트 값이 적용된다.
console.log(plus()); //NaN
console.log(plus(1,undefined)); //3
console.log(plus(1,3)); //4
console.log(plus(1)); //3

let getTotal = ([one, two] = [10, 20]) => one + two;
console.log(getTotal()); //30 파라미터 값을 넘겨주지 않았다. 디폴트 값[10, 20]이 적용 Array 분할 할당
console.log(getTotal([1,2])); //3

let getValue = ({two: value} = {two: 20}) => value; // Object 분할할당
console.log(getValue()); //20
console.log(getValue({two:5})); //5

//함수의 파라미터에 디스트럭처링과 디폴트 값을 오브젝트로 작성한 형태입니다.
```

### for-of

#### Array 반복

이터러블 오브젝트를 반복할 때마다 오브젝트의 프로퍼티를 구분할 수 있는 값이 variable변수에 설정됩니다.
iterableObject에 이터러블 오브젝트를 지정합니다.

```js
for (let value of [10, 20, 30]) {
    console.log(value);
}

for (const value of [10, 20, 30]) {
    console.log(value);
}

//for of 블록안에 value값을 변경하지 않으려면 const 사용
```
[10,20,30]은 이터러블 오브젝트로 배열 전체를 반복합니다.
반복할때마다 엘리먼트 값이 value변수에 설정됩니다.

#### String 사용
문자열을 반복할 수 있습니다.
```js
for (var value of "ABC") {
    console.log(value); // "A", "B", "C"
}
```

#### NodeList 반복
```js
let nodes = document.querySelectorAll("li");
for (var node of nodes) {
    console.log(node.textContent);
}

//document.querySelectorAll()과 같은 DOM 메서드를 실행하면 반환된 NodeList를 반복할 수 있다.

//textContent, innerText, innerHtml 차이
```
NodeList는 이터러블 오브젝트로 반복할 때마다 <li> 엘리먼트가 node 변수에 설정됩니다.

#### 디스트럭처링
```js
let values = [
    {item: "선물1", amount: {apple: 10, candy: 20}},
    {item: "선물2", amount: {apple: 30, candy: 40}}
];
for (var {item:one, amount: {apple: two, candy: five}} of values) {
    console.log(one, two, five);
}
```
values배열의 엘리먼트는 Object 오브젝트이며 for-of 문의 변수 형태도 같습니다.
즉, values배열의 Object 오브젝트를 for-of 문의 변수에 디스트럭처링 합니다.

### for-of와 for-in의 차이
```js
//for-in 문의 대상은 Object 오브젝트이며 열거 가능한 프로퍼티가 대상 죽, 프로퍼티의 enumerable 속성 값이 false이면 반복에서 제외
//for-of 문의 대상은 이터러블 오브젝트이며 prototype에 연결된 프로퍼티는 대상이 아닙니다.

let values = [10, 20, 30];
Array.prototype.music = function () {
    return "음악"
};
Object.prototype.sports = function() {
    return "스포츠"
};
for (var key in values) {
    console.log(key, values[key]);
};
console.log("<<<for-of>>>");
for (var value of values) {
    console.log(value);
}
/*
    values는 Array 오브젝트이므로 Array.prototype에 연결된 프로퍼티가 values.__proto__에 첨부
    music 메서드를 추가하면 values.__proto__와 Array.prototype이 연동되므로 values.music() 형태로 호출 가능

    Object.protype에 sports를 메서드를 추가하면, values.__proto__.__proto__(Array.prototype.__proto__)
    와 Object.prototype이 연동되므로 values.sports()로 호출가능

    for-in문은 개발자 코드로 추가한 메서드는 열거되고 빌트인으로 설정된 메서드는 열거되지 않는다.
*/
```
### for-of로 Object 열거

```js
let sports = {
    soccer: "축구",
    baseball: "야구"
};

let keyList = Object.keys(sports);
for (var key of keyList) {
    console.log(key, sports[key]);
};
/*
    Object.keys(sports)는 sports 오브젝트에서 프로퍼티 키를 배열로 반환
    keyList = ["soccer", "baseball"]
*/
```
배열은 이터러블 오브젝트이므로 이를 for-of문으로 반복하면서 sports[key] 형태로 프로퍼티 값을 구할 수 있다.

### 거듭 제곱 연산자
```js
console.log(3**2);
console.log(3**3);
console.log(Math.pow(3,3));
```

거듭 제곱(Exponentiation) 연산자는 곱하기 문자(*)를 연속하여 2개(**) 작성한 형태입니다. ES7 스펙에 추가되었습니다.
