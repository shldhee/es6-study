<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- <script>
        "use strict";
        let sports = "축구", music = "재즈";
        function get() {
            let music = "클래식";
            console.log(music);
            console.log(sports);
        }
        get();

        // 함수도 스코프를 가지므로 하나의 블록 스코프이다. ES5에선 함수에 선언된 모든 변수가 함수 스코프에 속한다.
        // ES6에서는 함수 안의 if 블록 {}은 다른 스코프이므로 계층 구조의 스코프가 형성됩니다. 스코프 안에 스코프가 있는 구조
        // var 변수와 마찬가지로 우선 함수 안에서 music 변수를 검색하고, 없으면 함수 밖으로 나가 검색합니다. 함수 안에 music 변수가 있으므로 "클래식"이 출력됩니다.
        // get() 함수 안에 sports 변수가 없으므로 함수 밖에 sports 변수 값인 "축구"를 출력합니다. let 변수도 가장 가까운 스코프에 있는 변수를 먼저 사용
    </script> -->
    <script>
        "use strict";
        var sports = "축구";
        let music = "재즈";

        function get() {
            var sports = "농구";
            let music = "클래식";
            console.log("1 : ", sports);
            console.log("2 : ", this.sports);
            console.log("3 : ", this.music);

        }
        window.get(); //농구, 축구, undefined(let this 접근 안됨)
        get(); //농구, 농구, 클래식

        /*
            window.get()와 같이 오브젝트를 지정하지 않고 get()호출하면 window 오브젝트를 참조하지 않는다.
            window.get(); 호출시 this가 window를 참조한다.
            하지만 let은 this로 참조 할 수 없어 undefined 출력

            get(); 호출시에는 앞에 오브젝트가 없으므로 "오브젝트.get()"형태 호출이 아닌
            undefined.get(); 으로 설정된다.
            따라서 this가 undefined를 참조하게 되므로 TypeError가 발생한다.
        */
    </script>
</body>
</html>
