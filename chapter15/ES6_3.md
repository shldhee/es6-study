# Object 오브젝트

### Object에 같은 key 사용
* ES3 key 값이 같더라도 추가
* ES5의 strict모드에서 에러
* ES6에서 strict모드 상관없이 나중에 작성된 프로퍼티 값 대체

```js
	let sameKey = {one:1, one:5};
	console.log('sameKey', sameKey); // Object { one: 5 }
```

### 변수 이름으로 값 설정
```js
let two = 2, three = 3;
let values = {two, three};  // two가 프로퍼티 이름이 되면서 two변수 값이 2가 프로퍼티 값으로 설정
console.log(values); //Object {two:2, three:3}
```

### Object에 function 작성
```js
/* ES5
let obj = {
	getTotal : function(param) {
		return param + 123;
	}
};
*/

//ES6
let obj = {
	getTotal(param) {
		return param + 123;
	}
};

console.log(obj.getTotal(400));
```

ES6 에서는  getTotal(param) {} 형태와 같이 콜론(:)과 function키워드를 작성하지 않았습니다.

## 디스크립터(서술자)
```js
Object.defineProperty({}. "book", {
	value : 123,
	enumerable: true
});
```

## get, set 속성
get 속성은 getter 기능을 제공
set 속성은 setter 기능을 제공


### get 속성
```js
var obj = {};
Object.defineProperty(obj, "book", {
	get: function() {
		return "책";
	}
});

console.log('obj.book', obj.book); // 책
```

1. 엔진이 (var result = obj.book) 코드를 해석하면, obj오브젝트에서 book프로퍼티 작성 여부 확인
2. 작성되어 있으면 get 속성의 존재 여부를 체크
3. 존재하면 get속성 값인 함수를 실행
4. 이것이 getter

### set 속성
```js
var obj = {};
Object.defineProperty(obj, "item", {
	set: function(param) {
		this.sports = param;
	}
});
obj.items = "야구";
console.log('obj.sports', obj.sports);
```


1. 엔진이 (obj.item = "야구";) 코드를 해석하면, obj오브젝트에서 book프로퍼티 작성 여부 확인
2. 작성되어 있으면 set 속성의 존재 여부를 체크
3. 존재하면 set속성 값인 함수를 실행
4. 이떄 "야구"를 실행하는 함수의 파라미터 값으로 넘겨준다.
5. 이것이 setter입니다.

setter가 호출되면 this.sports에서 this가 obj 오브젝트를 참조
**파라미터로 넘겨받은 "야구"를 obj 오브젝트의 sports 프로퍼티에 설정**

## getter
ES6
```js
"use script"
let obj = {
	value : 123,
	get getValue() {
		return this.value;
	}
};

console.log(obj.getValue);
```
