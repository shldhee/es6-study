1. 대용량의 청크(chunk) 데이터 사용을 위해 메모리 최적화를 도모하고 있습니다.
    ?청크(chunk)란 !큰 데이터인가 보다...

2. ES6는 객체지향 언의 장점을 적극적으로 도입

3. object 빌트인 오브젝트로 생성한 오브젝트 function sports() {} 빌트인 Function 오브젝트의 prototype에 연결된 프로퍼티(Property)로 오브젝트 생성

4. 인스턴스 new Sports()는 new 연산자와 Sports 생성자 함수로 인스턴스를 생성합니다.
    이와 같이 인스턴스와 오브젝트를 구분하는 이유는 Sports.prototype에 연결된 메서드를 호출하는 방법이 다르기 때문이다.

    Sports.prototype에 연결된 메서드를 호출하려면 Sports.prototype.method() 형태로 작성해야 합니다. 이때 Sports는 오브젝트입니다.
    그런데 new Sports()로 인스턴스를 새엇ㅇ하여 instance 변수에 할당하면 instance.method() 형태로 호출합니다.

5. 프로퍼티 key와 name
    var obj = {sports: "축구"}
    ES5 sports를 프로퍼티 이름 또는  key라고 부름
    ES6 에서는 구분해야됨
    ES6에서 프로퍼티 이름은 문자열 타입의 이름을 나타냅니다.
    프로퍼티 키는 여기에 Symbol 값이 포함됩니다.

6. 함수와 메서드
    함수는 function sports() {} 와 같이 function 키워드를 사용한 형태입니다.
    ES5에서 Array.isArray()와 같이 오브젝트 프로퍼티로 작성된 isArray()를 함수라고 했으며
    Sports.prototype.get = function(){}과 같이 prototype에 연결된 get()을 메서드라고 했습니다.

    ?객체값이 함수면 메서드인줄 알았는데...

    메소드는 위에서 설명하였듯이 객체가 가지고 있는 동작이다.
    메소드를 수행하기 위해서는 객체를 통해서 해당 메소드를 수행하여야 한다.
    즉 그 동작을 수행하는 주체는 객체이며 그 동작을 수행하기 위해서는 객체에게 그 동작을 수행하라고 지시해야 한다.
    함수는 그 동작을 수행하기 위해 객체에게 어떤을 동작을 수행하라고 명령하지 않아도 된다.
    그이유는 함수자체가 그 동작을 정의한 함수객체이기 때문에 자기 자신을 수행하는 것이다.
    함수객체라는 것에 대해서는 이후에 자세히 설명하도록 하겠다.
    어찌 되었건 메소드는 객체를 움직이는 동작이며 그 동작을 수행하기 위해서 객체의 정보를 담고있는 프로퍼티를 사용할수 있다.

    함수와 메서드를 구분해야 하는 이유 : new 연산자로 인스턴스를 생성할 때 인스턴스에 할당되는 기준이 다르기 때문이다.
    (var values = [1,2,3];)을 실행하면 Array 오브젝트를 생성하여 values 변수에 할당합니다.
    이때, Array.isArray()는 values 변수에 할당되지 않고 Array.prototype에 연결된 forEach()와 같은 메서드만 할당됩니다.
    생성한 인스턴스에서 forEach()는 호출되지만, isArray()는 호출되지 않습니다.
