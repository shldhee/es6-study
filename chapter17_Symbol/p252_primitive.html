<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>P251. primitive</title>
</head>
<body>
	<script type="text/javascript">
		'use strict';
		/*
			ES5의 원시타입(primitive type) string, number, boolean, null, undefined가 있다.
			ES6에서 symbol이 추가되었다.

			ES5의 래퍼(Wrapper) 오브젝트는 string은 String 오브젝트, number는 Number 오브젝트, boolean은 Boolean 오브젝트가 있다.
			ES6에서 symbol의 Symbol 오브젝트가 추가

			---
			원시 래퍼 타입(래퍼 오브젝트) : 원시 값을 편리하게 조작하기 위해 디자인된 참조 타입이다.

			var text1 = "some";
			var text2 = text1.substring(2);

			원시 값은 객체가 아니므로 논리적으로 메서드를 가질 수 없지만 별다른 코드 없이도 메서드를 호출한다.
			내부에서 일어나는 일은 다음과 같다.

			var text1 = "some";
			var temp = new String(text1);
			var text2 = temp.substring(2);
			temp = null;

			참조 타입과 원시 래퍼 타입 주요 차이는 생명주기
			참조 타입은 new 연산자를 사용해 인스턴스를 만들면 스코프를 벗어날 때까지 존재
			원시 래퍼 타입은 해당 행을 벗어나는 즉시 파괴
		*/

		const sym = Symbol();  // Symbol() 호출하면 Symbol 값을 생성하여 반환, 생성한 값은 변경할 수 없으므로 const 변수에 할당해도 된다.
		console.log('1:', sym);					// Symbol();
		// Symbol()로 값을 생성했는데 값이 출력되지 않는다. **Symbol 값을 구하면 Symbol 값을 생성했던 형태를 반환**
		console.log('2:', typeof sym);			// symbol
		console.log('3:', Symbol('주석'));	  // Symbol(주석)
		// Symbol()의 파라미터는 선택으로 Symbol()로 생성한 값의 설명이나 주석을 문자열로 작성, 작성하지 않으면 undefined로 인식
		console.log('4:', sym == Symbol());		// false
		// Symbol()을 실행할 때마다 프로그램 전체를 통해 유일한 값으로 생성하므로 값이 항상 다르다.
	</script>
</body>
</html>
