<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>p271_species</title>
</head>
<body>
	<script type="text/javascript">
		/*
			Symbol.species는 constructor를 반환합니다.
			constructor를 반환한다는 것은 constructor로 인스턴스를 생성하여 반화하는 것과 같습니다.
			오버라이드 할 수 있고, 개발자 코드로 반환되는 인스턴스를 변경 할 수 있습니다.
		*/

		let arrayObj = [1, 2, 3];
		/*
			1. [1,2,3] 실행
			2. Array 오브젝트(인스턴스) 생성
			3. 엘리먼트 값으로 1,2,3 설정

			arrayObj 구성을 보면 prototype이 없으며 __proto__에 Array 오브젝트의 prototype에 연결된 프로퍼티가 첨부되어 있다.
			Array 오브젝트 프로퍼티로 isArray()가 연결되어 있으나, arrayObj에는 없다.
			따라서 arrayObj는 Array 오브젝트가 아닌 Array 인스턴스이다.
		*/
		let sliceOne = arrayObj.slice(1, 3); // slice()는 첫 번째 파라미터 인덱스(1)부터 두 번째 파라미터 인덱스 직전(3-1 = 2 즉 2까지)까지의 엘리먼트 값을 반환
		/*
			이 코드는 [1,2,3].slice(1,3) 하고 다르다.
			[1,2,3]으로 Array 인스턴스를 생성하여 arrayObj에 할당하고, arrayObj에 있는 slice()을 호출하는 형태

			arrayObj.slice(1,3)을 실행하면 [1,2,3]에서 2와 3이 반환되어 sliceOne 변수에 할당 될 것으로 생각할 수 있습니다.
			하지만, sliceOne 변수에 할당되는 것은 Array 인스턴스입니다.
			slice()를 호출하는 arrayObj 인스턴스와 slice() 결과가 할당된 sliceOne 인스턴스는 모두 인스턴스로 차이가 없습니다.
			다만, 배열의 엘리먼트 값이 다릅니다.
		*/
		let sliceTwo = sliceOne.slice(1, 2);


		class ExtendArray extends Array { // ExtendArray 클래스에서 Array 오브젝트를 상속받아 인스턴스를 생성
			getValue(){}
		}
		let newArray = new ExtendArray(1,2,3); // ExtendArray() 파라미터에 지정한 1,2,3이 생성하는 인스턴스에 설정

		let newInst = newArray.slice(1,2); // newArray 인스턴스의 slice() 호출하면 Array 인스턴스를 반환 이 인스턴스에 slice(1, 2) 결과가 설정된다.
		console.log(newInst instanceof ExtendArray); // newInst는 앞에서 slice() 호출 했을 반환된 인스턴스

		// 이처럼 인스턴스의 메서드를 호출했을 때 인스턴스를 반환하도록 하는 것이 Symbol.species

	</script>
</body>
</html>
