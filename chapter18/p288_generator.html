<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>p288_generator</title>
</head>
<body>
	<script type="text/javascript">
		/*
			Object 오브젝트에 Symbo.iterator를 제너레이터 함수로 작성하면, 이터레이터로 반복할 때마다 yield를 수행합니다.
		*/

		let obj = {};
		obj[Symbol.iterator] = function*() { // obj 오브젝트의 [Symbol.iterator]를 제너레이터 함수로 작성 이터레이터로 반복할 때마다 yield 표현식의 값을 반환
			yield 10;
			yield 20;
			yield 30;
		};
		let result = [...obj];
		/*
			대괄호 [ ]안에 spread 연산자로 obj 오브젝트 작성, [...obj]를 시작하게 되면 우선 obj 오브젝트에서 [Symbol.iterator] 작성 여부 체크
			작성되어 있으므로 [Symbol.iterator]()가 호출되며 이터레이터 오브젝트를 생성하여 반환합니다. 이터레이터가 반복될 때마다 yield에서 반환된 값을 반환활 배열에 첨부
			반복이 끝나면 배열을 반환합니다.
		*/
		console.log(result);

		console.log('----iterator-next----');

		let gen = function*() { // 제네레이터 함수 선언하고 두 개의 yield를 작성
			yield 10;
			yield 20;
		}
		let genObj = gen(); // 제너레이터 함수 호출하면 제너레이터 오브젝트를 생성하여 genObj에 할당
		console.log(genObj.next()); // { value: 10, done: false }

		let iteratorObj = genObj[Symbol.iterator](); // 제너레이터 오브젝트의 [Symbol.iterator]()를 호출하면 이터레이터 오브젝트를 생성하여 반환
		// 제너레이터 함수의 prototype의 __proto__에 [Symbol.iterator]()가 있으므로 제너레이터 오브젝트에서 [Symbol.iterator]()을 호출할 수 있다.

		console.log('iteratorObj.next()', iteratorObj.next()); // { value: 20, done: false }
		// 제너레이터 오브젝트가 아닌 이터레이터 오브젝트의 next()를 호출, 두 번째 yield를 수행하여 반환, 제너레이터 오브젝트에 [Symbol.iterator]()가 있으므로 앞서 제너레이터 오브젝트에서 수행한 yield를 이터레이터 오브젝트에서 공유할 수 있다.

	</script>
</body>
</html>
